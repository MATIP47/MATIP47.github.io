<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Maze</title>
<style>
html,body{height:100%;margin:0;background:#000;overflow:hidden}
canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}
#fullscreenBtn{
  position:absolute;left:12px;top:12px;z-index:100;
  background:rgba(0,0,0,0.6);color:#fff;border:0;padding:8px 10px;
  cursor:pointer;font-family:sans-serif;border-radius:4px;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="fullscreenBtn">Fullscreen</button>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:false});
let radarScale = 8;
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

const MAX_MAZE_SIZE = 75;
const RENDER_DEPTH = 65;
const FOV = 60 * Math.PI/180;
const playerRadius = 0.12; 
const baseSpeed = 1.5;

let maze = [];
let flickerLights = [];
let enemies = [];
let invincible = false;

// Shuffle helper
function shuffle(arr, rand) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(rand() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }

// Maze generation function remains as before
function generateMaze() { /* your maze generation code */ }

// Enemy class
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.speed = 1.2;
        this.noclip = false;
        this.visible = false;
        this.alpha = 0;
    }
    update(dt, radarLineAngle){
        this.angle = player.angle; 
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const moveX = Math.cos(this.angle)*this.speed*dt;
        const moveY = Math.sin(this.angle)*this.speed*dt;
        if(!this.noclip){
            if(getCell(Math.floor(this.x+moveX),Math.floor(this.y+moveY))===0){this.x+=moveX; this.y+=moveY;}
        } else { this.x+=moveX; this.y+=moveY; if(getCell(Math.floor(this.x),Math.floor(this.y))===0) this.noclip=false;}
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(!invincible && dist<0.5){ player.x=Math.floor(MAX_MAZE_SIZE/2)+0.5; player.y=Math.floor(MAX_MAZE_SIZE/2)+0.5; }

        // Radar detection with slower fade
        const angleToEnemy=Math.atan2(this.y-player.y,this.x-player.x);
        const radarDiff=Math.atan2(Math.sin(radarLineAngle-angleToEnemy),Math.cos(radarLineAngle-angleToEnemy));
        if(Math.abs(radarDiff)<0.03){ this.visible=true; this.alpha=1; }
        else if(this.alpha>0){ this.alpha-=dt*0.15; if(this.alpha<0)this.alpha=0; }
    }
    drawRadar(){
        if(this.alpha<=0) return;
        const baseRadarRadius=120;
        const radarRadius=baseRadarRadius*1.5;
        const cx=canvas.width - radarRadius - 0.02*canvas.width;
        const cy=radarRadius+0.02*canvas.height;
        ctx.save(); ctx.translate(cx,cy);
        const px=(this.x-player.x)*radarScale; const py=(this.y-player.y)*radarScale;
        if(Math.sqrt(px*px+py*py)<radarRadius-2){ctx.globalAlpha=this.alpha; ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;}
        ctx.restore();
    }
    draw3D(){
        if(this.alpha<=0) return;
        const w=1,h=1;
        const screenX=(this.x-player.x)*10+canvas.width/2;
        const screenY=(this.y-player.y)*10+canvas.height/2;
        ctx.globalAlpha=this.alpha;
        ctx.fillStyle='red';
        ctx.fillRect(screenX-w/2, screenY-h/2, w, h);
        ctx.globalAlpha=1;
    }
}

// Footsteps
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const footstepAudio = new Audio('sounds/footsteps.mp3'); footstepAudio.preload='auto'; footstepAudio.load();
let lastFootstepTime=0;
function playFootstep(){
    if(audioCtx.state==='suspended') audioCtx.resume();
    footstepAudio.playbackRate=0.9+Math.random()*0.3;
    footstepAudio.volume=0.2+Math.random()*0.3;
    footstepAudio.currentTime=0;
    footstepAudio.play();
}

// Player, movement, radar, render, etc. remain as before

// Spawn enemy after 60s
setTimeout(()=>{
    let tries=0;
    while(tries<100){
        let gx=Math.floor(Math.random()*MAX_MAZE_SIZE);
        let gy=Math.floor(Math.random()*MAX_MAZE_SIZE);
        if(getCell(gx,gy)===0){ enemies.push(new Enemy(gx+0.5,gy+0.5)); break; }
        tries++;
    }
},60000);

addEventListener('keydown', e=>{
    if(e.code==='KeyI') invincible=!invincible;
    if(e.code==='KeyE'){
        let ex=player.x+Math.cos(player.angle)*3;
        let ey=player.y+Math.sin(player.angle)*3;
        let noclip=false;
        if(getCell(Math.floor(ex),Math.floor(ey))!==0) noclip=true;
        const enemy=new Enemy(ex,ey); enemy.noclip=noclip; enemies.push(enemy);
    }
    if(e.code==='Minus'||e.code==='NumpadSubtract'){ radarScale=Math.max(2,radarScale-1); e.preventDefault();}
    if(e.code==='Equal'||e.code==='NumpadAdd'){ radarScale=Math.min(20,radarScale+1); e.preventDefault();}
});

let last=performance.now();
function loop(){
    const now=performance.now(), dt=(now-last)/1000; last=now;
    const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
    const strafe=(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
    const dx=(forward*Math.cos(player.angle)-strafe*Math.sin(player.angle))*player.speed;
    const dy=(forward*Math.sin(player.angle)+strafe*Math.cos(player.angle))*player.speed;
    movePlayer(dx,dy,dt);

    const radarLineAngle=now*0.002;
    for(const enemy of enemies){enemy.update(dt, radarLineAngle);}

    render();

    // Draw 3D enemies when pinged
    for(const enemy of enemies){enemy.draw3D();}

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

canvas.addEventListener('click',()=>canvas.requestPointerLock());
addEventListener('mousemove', e=>{if(document.pointerLockElement===canvas){player.angle+=e.movementX*0.0022;}});

document.getElementById('fullscreenBtn').addEventListener('click',()=>{
    if(!document.fullscreenElement)document.documentElement.requestFullscreen();
    else document.exitFullscreen();
});
</script>
</body>
</html>
