<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Maze</title>
<style>
html,body{height:100%;margin:0;background:#000;overflow:hidden}
canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}
#fullscreenBtn{
  position:absolute;left:12px;top:12px;z-index:100;
  background:rgba(0,0,0,0.6);color:#fff;border:0;padding:8px 10px;
  cursor:pointer;font-family:sans-serif;border-radius:4px;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="fullscreenBtn">Fullscreen</button>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:false});
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

const CHUNK=175;
const FOV = 60*Math.PI/180;
const playerRadius=0.12;
const baseSpeed=1.5;
let player={x:CHUNK/2+0.5,y:CHUNK/2+0.5,angle:0,speed:baseSpeed,bobPhase:0,tilt:0};
const keys={};
addEventListener('keydown',e=>keys[e.code]=true);
addEventListener('keyup',e=>keys[e.code]=false);

let maze = new Array(CHUNK*CHUNK).fill(1);
function index(x,y){return y*CHUNK+x;}
function generateMaze(){
  for(let y=1;y<CHUNK-1;y++){
    for(let x=1;x<CHUNK-1;x++){
      maze[index(x,y)]=Math.random()<0.15?1:0;
    }
  }
  for(let i=0;i<CHUNK;i++){maze[index(i,0)]=maze[index(i,CHUNK-1)]=1; maze[index(0,i)]=maze[index(CHUNK-1,i)]=1;}
}
generateMaze();
function getCell(x,y){x=Math.floor(x);y=Math.floor(y);if(x<0||y<0||x>=CHUNK||y>=CHUNK)return 1;return maze[index(x,y)];}

class Enemy{
  constructor(x,y){this.x=x;this.y=y;this.angle=0;this.speed=1.2;this.alpha=0;}
  update(dt,radarAngle){
    const dx=player.x-this.x,dy=player.y-this.y;
    this.angle=Math.atan2(dy,dx);
    const moveX=Math.cos(this.angle)*this.speed*dt;
    const moveY=Math.sin(this.angle)*this.speed*dt;
    if(getCell(this.x+moveX,this.y+moveY)===0){this.x+=moveX;this.y+=moveY;}
    const dist=Math.hypot(dx,dy);
    if(dist<0.5&&!invincible){player.x=CHUNK/2+0.5;player.y=CHUNK/2+0.5;}
    const aToEnemy=Math.atan2(this.y-player.y,this.x-player.x);
    const diff=Math.atan2(Math.sin(radarAngle-aToEnemy),Math.cos(radarAngle-aToEnemy));
    if(Math.abs(diff)<0.03)this.alpha=1; else if(this.alpha>0){this.alpha-=dt*0.15;if(this.alpha<0)this.alpha=0;}
  }
  drawRadar(cx,cy,radius){
    if(this.alpha<=0)return;
    ctx.save();ctx.translate(cx,cy);ctx.rotate(-player.angle-Math.PI/2);
    const px=(this.x-player.x)*8,py=(this.y-player.y)*8;
    if(Math.hypot(px,py)<radius-2){ctx.globalAlpha=this.alpha;ctx.fillStyle='red';ctx.beginPath();ctx.arc(px,py,4,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;}
    ctx.restore();
  }
  draw3D(){
    if(this.alpha<=0)return;
    const dx = this.x - player.x;
    const dy = this.y - player.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 0.5) return;
    let angleToEnemy = Math.atan2(dy, dx) - player.angle;
    while(angleToEnemy > Math.PI) angleToEnemy -= 2*Math.PI;
    while(angleToEnemy < -Math.PI) angleToEnemy += 2*Math.PI;
    if(Math.abs(angleToEnemy) > FOV/2) return;
    const wallHeight = canvas.height*0.5 / dist;
    const projectedWidth = wallHeight * 0.5;
    const screenX = canvas.width/2 + Math.tan(angleToEnemy)*canvas.width/(2*Math.tan(FOV/2)) - projectedWidth/2;
    const screenY = canvas.height/2 - wallHeight/2;
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = 'red';
    ctx.fillRect(screenX, screenY, projectedWidth, wallHeight);
    ctx.globalAlpha = 1;
  }
}
let enemies=[];
let invincible=false;
setTimeout(()=>{enemies.push(new Enemy(player.x+2,player.y+2));},60000);

function drawRadar(){
  const baseRadius=120;const radarRadius=baseRadius*1.5;
  const cx=canvas.width-radarRadius-0.02*canvas.width;
  const cy=radarRadius+0.02*canvas.height;
  ctx.save();ctx.beginPath();ctx.arc(cx,cy,radarRadius,0,Math.PI*2);ctx.clip();
  ctx.save();ctx.translate(cx,cy);ctx.rotate(-player.angle-Math.PI/2);
  ctx.save();ctx.scale(8,8);
  const maxCells=(radarRadius-2)/8+1;const px=player.x,py=player.y;
  ctx.strokeStyle='#999';ctx.lineWidth=0.5;
  for(let gx=Math.floor(px-maxCells);gx<=Math.ceil(px+maxCells);gx++){
    for(let gy=Math.floor(py-maxCells);gy<=Math.ceil(py+maxCells);gy++){
      if(getCell(gx,gy)===1){const dx=gx-px,dy=gy-py;if(Math.hypot(dx,dy)<radarRadius-2){ctx.strokeRect(dx,dy,1,1);}}}
  ctx.restore();ctx.restore();
  const angles=[45,135,225,315].map(a=>a*Math.PI/180);
  const inner=[radarRadius*0.66,radarRadius*0.33,radarRadius*0.15];
  for(const r of inner){ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.strokeStyle='#333';ctx.lineWidth=1;ctx.stroke();}
  for(const a of angles){ctx.beginPath();ctx.moveTo(cx+inner[2]*Math.cos(a),cy+inner[2]*Math.sin(a));ctx.lineTo(cx+radarRadius*Math.cos(a),cy+radarRadius*Math.sin(a));ctx.strokeStyle='#333';ctx.lineWidth=1;ctx.stroke();}
  const t=performance.now()*0.002;ctx.beginPath();ctx.moveTo(cx,cy);
  ctx.lineTo(cx+Math.cos(t)*radarRadius,cy+Math.sin(t)*radarRadius);ctx.strokeStyle='#333';ctx.lineWidth=1;ctx.stroke();
  for(const e of enemies)e.drawRadar(cx,cy,radarRadius);
  ctx.fillStyle='red';ctx.beginPath();ctx.arc(cx,cy,6,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

function castRay(rayAngle){
  let dist=0;const step=0.02;
  let hit=false;
  let side=0;
  let hitX=0,hitY=0;
  while(!hit && dist<20){
    dist+=step;
    const testX = player.x + Math.cos(rayAngle)*dist;
    const testY = player.y + Math.sin(rayAngle)*dist;
    if(getCell(testX,testY)===1){
      hit=true;
      hitX = testX;
      hitY = testY;
    }
  }
  if(!hit) return {dist:20,side:0};
  const blockX = Math.floor(hitX);
  const blockY = Math.floor(hitY);
  const deltaX = hitX - blockX;
  const deltaY = hitY - blockY;
  if(deltaX<0.01 || deltaX>0.99) side=0; else side=1;
  return {dist,side};
}

function render(){
  ctx.fillStyle='rgb(30,30,40)';
  ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle='rgb(150,100,50)';
  ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);

  const numRays = canvas.width;
  const halfHeight = canvas.height/2;
  for(let i=0;i<numRays;i++){
    const rayScreenPos = (i / numRays) - 0.5;
    const rayAngle = player.angle + rayScreenPos * FOV;
    let {dist,side} = castRay(rayAngle);
    dist *= Math.cos(rayAngle - player.angle);
    const wallHeight = Math.min(canvas.height, (canvas.height*1.3) / dist);
    const wallTop = halfHeight - wallHeight/2;
    const wallBottom = wallTop + wallHeight;
    const baseColor=side===0?180:160;
    ctx.fillStyle=`rgb(${baseColor+Math.random()*5|0},${baseColor-20+Math.random()*5|0},80)`;
    ctx.fillRect(i,wallTop,1,wallHeight);
  }

  for(const e of enemies)e.draw3D();
  drawRadar();
}

let last=performance.now();
function loop(){
  const now=performance.now();
  const dt=(now-last)/1000; last=now;
  const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
  const strafe=(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
  const dx=(forward*Math.cos(player.angle)-strafe*Math.sin(player.angle))*player.speed;
  const dy=(forward*Math.sin(player.angle)+strafe*Math.cos(player.angle))*player.speed;
  player.x+=dx*dt;player.y+=dy*dt;player.bobPhase+=dt*6;

  for(const e of enemies)e.update(dt,player.angle);

  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

canvas.addEventListener('click',()=>canvas.requestPointerLock());
addEventListener('mousemove',e=>{if(document.pointerLockElement===canvas){player.angle+=e.movementX*0.0022;}});
document.getElementById('fullscreenBtn').addEventListener('click',()=>{if(!document.fullscreenElement)document.documentElement.requestFullscreen();else document.exitFullscreen();});
</script>
</body>
</html>
