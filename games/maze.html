<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Maze</title>
<style>
html,body{height:100%;margin:0;background:#000;overflow:hidden}
canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}
#fullscreenBtn{
  position:absolute;left:12px;top:12px;z-index:100;
  background:rgba(0,0,0,0.6);color:#fff;border:0;padding:8px 10px;
  cursor:pointer;font-family:sans-serif;border-radius:4px;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="fullscreenBtn">Fullscreen</button>
<script>
let enemies = [];
let invincible = false;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:false});
let radarScale = 8; // Initial scale for minimap
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

const MAX_MAZE_SIZE = 75;
const RENDER_DEPTH = 65;
const FOV = 60 * Math.PI/180;
const playerRadius = 0.12; 
const baseSpeed = 1.5;

// Maze storage: 0=open, 1=wall
let maze = [];
let flickerLights = [];

// Shuffle helper
function shuffle(arr, rand) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

// Maze generation
function generateMaze() {
  maze = [];
  for (let y = 0; y < MAX_MAZE_SIZE; y++) {
    let row = [];
    for (let x = 0; x < MAX_MAZE_SIZE; x++) row.push(1);
    maze.push(row);
  }

  let stack = [];
  maze[1][1] = 0;
  stack.push([1,1]);
  let rand = Math.random;

  while (stack.length) {
    let [x, y] = stack[stack.length - 1];
    let dirs = [[2,0],[-2,0],[0,2],[0,-2]];
    shuffle(dirs, rand);
    let carved = false;
    for (const [dx,dy] of dirs) {
      let nx = x+dx, ny = y+dy;
      if (nx>0 && nx<MAX_MAZE_SIZE-1 && ny>0 && ny<MAX_MAZE_SIZE-1 && maze[ny][nx]===1) {
        if (nx>=1 && nx<=MAX_MAZE_SIZE-2 && ny>=1 && ny<=MAX_MAZE_SIZE-2) {
          maze[y+dy/2][x+dx/2] = 0;
          maze[ny][nx] = 0;
          stack.push([nx,ny]);
          carved = true;
          if (rand() < 0.8) { // more open passages
            let sideDirs = [[1,0],[-1,0],[0,1],[0,-1]];
            let [sdx,sdy] = sideDirs[Math.floor(rand()*sideDirs.length)];
            let sx = x+sdx, sy = y+sdy;
            if (sx>0 && sx<MAX_MAZE_SIZE-1 && sy>0 && sy<MAX_MAZE_SIZE-1 && maze[sy][sx]===1) {
              maze[sy][sx] = 0;
            }
          }
          break;
        }
      }
    }
    if (!carved) stack.pop();
  }

  // Reduce dead ends
  for (let y=1;y<MAX_MAZE_SIZE-1;y++) {
    for (let x=1;x<MAX_MAZE_SIZE-1;x++) {
      if (maze[y][x]===0) {
        let neighbors = [[0,-1],[0,1],[-1,0],[1,0]];
        let openCount = 0;
        for (const [dx,dy] of neighbors) if (maze[y+dy][x+dx]===0) openCount++;
        if (openCount===1 && Math.random()<0.7) {
          let wallNeighbors = neighbors.filter(([dx,dy])=>maze[y+dy][x+dx]===1);
          if (wallNeighbors.length>0) {
            let [dx,dy] = wallNeighbors[Math.floor(Math.random()*wallNeighbors.length)];
            maze[y+dy][x+dx]=0;
          }
        }
      }
    }
  }

  // Boundaries
  for (let x=0;x<MAX_MAZE_SIZE;x++){ maze[0][x]=1; maze[MAX_MAZE_SIZE-1][x]=1; }
  for (let y=0;y<MAX_MAZE_SIZE;y++){ maze[y][0]=1; maze[y][MAX_MAZE_SIZE-1]=1; }

  // Flicker lights
  flickerLights = [];
  let lightsPerBlock = 2;
  let block = 32;
  for (let by=1;by<MAX_MAZE_SIZE-1;by+=block){
    for (let bx=1;bx<MAX_MAZE_SIZE-1;bx+=block){
      for (let i=0;i<lightsPerBlock;i++){
        let tries=0;
        while (tries<20){
          let lx = bx+1+Math.floor(rand()*(block-2));
          let ly = by+1+Math.floor(rand()*(block-2));
          if (lx>0&&lx<MAX_MAZE_SIZE-1&&ly>0&&ly<MAX_MAZE_SIZE-1&&maze[ly][lx]===0){
            flickerLights.push({gx:lx,gy:ly,phase:rand()*Math.PI*2,speed:0.005+rand()*0.005,on:true});
            break;
          }
          tries++;
        }
      }
    }
  }
}

function getCell(gx,gy){
  if (gx<0||gy<0||gx>=MAX_MAZE_SIZE||gy>=MAX_MAZE_SIZE) return 1;
  return maze[gy][gx];
}

function findSafeSpawn(){
  for (let r=1;r<80;r++){
    for (let i=0;i<100;i++){
      const gx=Math.floor((Math.random()*2-1)*r)+Math.floor(MAX_MAZE_SIZE/2);
      const gy=Math.floor((Math.random()*2-1)*r)+Math.floor(MAX_MAZE_SIZE/2);
      if (gx<1||gy<1||gx>=MAX_MAZE_SIZE-1||gy>=MAX_MAZE_SIZE-1) continue;
      if (getCell(gx,gy)===0){
        if (getCell(gx+1,gy)===0&&getCell(gx-1,gy)===0&&getCell(gx,gy+1)===0&&getCell(gx,gy-1)===0){
          return [gx+0.5, gy+0.5];
        }
      }
    }
  }
  return [1.5,1.5];
}

generateMaze();
let player={x:0,y:0,angle:0,speed:baseSpeed,bobPhase:0,tilt:0};
[player.x,player.y]=findSafeSpawn();

const keys={};
addEventListener('keydown',e=>keys[e.code]=true);
addEventListener('keyup',e=>keys[e.code]=false);

addEventListener('keydown',e=>{
  if (e.code==='Minus'||e.code==='NumpadSubtract'){ radarScale=Math.max(2,radarScale-1); e.preventDefault();}
  if (e.code==='Equal'||e.code==='NumpadAdd'){ radarScale=Math.min(20,radarScale+1); e.preventDefault();}
});
addEventListener('keydown',e=>{
    if(e.code==='KeyI') invincible=!invincible;
    if(e.code==='KeyE'){
        let ex=player.x+Math.cos(player.angle)*3;
        let ey=player.y+Math.sin(player.angle)*3;
        let noclip=false;
        if(getCell(Math.floor(ex), Math.floor(ey))!==0) noclip=true;
        const enemy=new Enemy(ex,ey); enemy.noclip=noclip; enemies.push(enemy);
    }
});

class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.speed = 1.2;
        this.noclip = false;
    }
    update(dt) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const enemyAngleToPlayer = Math.atan2(dy, dx);
        const diff = Math.atan2(Math.sin(enemyAngleToPlayer - this.angle), Math.cos(enemyAngleToPlayer - this.angle));
        if (Math.abs(diff) < Math.PI/4) { this.angle = enemyAngleToPlayer; }
        const moveX = Math.cos(this.angle) * this.speed * dt;
        const moveY = Math.sin(this.angle) * this.speed * dt;
        if (!this.noclip) {
            if (getCell(Math.floor(this.x+moveX), Math.floor(this.y+moveY))===0) { this.x+=moveX; this.y+=moveY; }
        } else { this.x+=moveX; this.y+=moveY; if(getCell(Math.floor(this.x), Math.floor(this.y))===0) this.noclip=false; }
        if(!invincible && dist<0.5){ player.x=Math.floor(MAX_MAZE_SIZE/2)+0.5; player.y=Math.floor(MAX_MAZE_SIZE/2)+0.5; }
    }
    draw() {
        const baseRadarRadius=120;
        const radarRadius=baseRadarRadius*1.5;
        const cx=canvas.width - radarRadius - 0.02 * canvas.width;
        const cy=radarRadius + 0.02 * canvas.height;
        ctx.save(); ctx.translate(cx,cy);
        const px=(this.x-player.x)*radarScale, py=(this.y-player.y)*radarScale;
        if(Math.sqrt(px*px+py*py)<radarRadius-2){ ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
    }
}

setTimeout(()=>{
    let tries=0;
    while(tries<100){
        let gx=Math.floor(Math.random()*MAX_MAZE_SIZE);
        let gy=Math.floor(Math.random()*MAX_MAZE_SIZE);
        if(getCell(gx,gy)===0){ enemies.push(new Enemy(gx+0.5,gy+0.5)); break; }
        tries++;
    }
},60000);

let sprintMax=5,sprintCurrent=sprintMax,isRegenerating=false;

function isBlockedAtPos(px,py){
  const offs=[[playerRadius,0],[-playerRadius,0],[0,playerRadius],[0,-playerRadius]];
  for(const[ox,oy]of offs){
    const gx=Math.floor(px+ox),gy=Math.floor(py+oy);
    if(getCell(gx,gy)===1) return true;
  }
  return false;
}

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const footstepAudio = new Audio('sounds/footstep.mp3');
footstepAudio.preload = 'auto';
footstepAudio.load();

let lastFootstepTime = 0;
function playFootstep() {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
  const sound = footstepAudio.cloneNode();
  sound.playbackRate = 0.9 + Math.random() * 0.3; // pitch between 0.9 and 1.2
  sound.volume = 0.2 + Math.random() * 0.3; // volume between 0.2 and 0.5
  sound.play();
}

function movePlayer(dx,dy,dt){
  let isMoving=dx!==0||dy!==0;
  let sprinting=keys['ShiftLeft']&&isMoving&&sprintCurrent>0&&!isRegenerating;
  if(sprintCurrent<=0) sprinting=false;

  if(sprinting){
    player.speed=baseSpeed*1.4;
    sprintCurrent-=dt;
    if(sprintCurrent<0){sprintCurrent=0;isRegenerating=true;}
  } else {
    if(isRegenerating){
      sprintCurrent+=dt*0.8; player.speed=baseSpeed*0.5;
      if(sprintCurrent>=sprintMax){sprintCurrent=sprintMax;isRegenerating=false;player.speed=baseSpeed;}
    } else {
      sprintCurrent+=dt*0.8; if(sprintCurrent>sprintMax)sprintCurrent=sprintMax; player.speed=baseSpeed;
    }
  }

  const moveX=dx*dt, moveY=dy*dt;
  if(!isBlockedAtPos(player.x+moveX,player.y+moveY)){player.x+=moveX;player.y+=moveY;}
  else{
    if(!isBlockedAtPos(player.x+moveX,player.y)) player.x+=moveX;
    if(!isBlockedAtPos(player.x,player.y+moveY)) player.y+=moveY;
  }
  if(isMoving) {
    player.bobPhase+=dt*(sprinting?6*1.8:6);
    const now = performance.now();
    const interval = 600 / player.speed; // interval in ms, slower frequency of footsteps
    if (now - lastFootstepTime > interval) {
      playFootstep();
      lastFootstepTime = now;
    }
  } else {
    player.tilt=0;
  }
  player.tilt=isMoving?Math.sin(player.bobPhase*2)*0.04:0;
}

function castRay(px,py,angle){
  const sin=Math.sin(angle),cos=Math.cos(angle);
  for(let t=0;t<RENDER_DEPTH;t+=0.02){
    const rx=px+cos*t, ry=py+sin*t;
    const gx=Math.floor(rx), gy=Math.floor(ry);
    if(getCell(gx,gy)===1) return {dist:t,gx,gy,hitX:rx,hitY:ry};
  }
  return {dist:RENDER_DEPTH,gx:null,gy:null,hitX:px+cos*RENDER_DEPTH,hitY:py+sin*RENDER_DEPTH};
}

function drawRadar(){
  const baseRadarRadius=120;
  const radarRadius=baseRadarRadius*1.5;
  const cx=canvas.width - radarRadius - 0.02 * canvas.width;
  const cy=radarRadius + 0.02 * canvas.height;
  ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,radarRadius,0,Math.PI*2); ctx.clip();
  ctx.fillStyle='#ddd'; ctx.fillRect(cx-radarRadius,cy-radarRadius,radarRadius*2,radarRadius*2);

  ctx.save(); ctx.translate(cx,cy); ctx.rotate(-player.angle-Math.PI/2);
  ctx.save(); ctx.scale(radarScale,radarScale);
  const maxCells=(radarRadius-2)/radarScale+1;
  const playerCellX=player.x, playerCellY=player.y;
  ctx.fillStyle='#ff0';
  for(let gx=Math.floor(playerCellX-maxCells);gx<=Math.ceil(playerCellX+maxCells);gx++){
    for(let gy=Math.floor(playerCellY-maxCells);gy<=Math.ceil(playerCellY+maxCells);gy++){
      if(getCell(gx,gy)===1){
        const px=gx-playerCellX, py=gy-playerCellY;
        const distPx=Math.sqrt(px*px+py*py)*radarScale;
        if(distPx<radarRadius-2) ctx.fillRect(px,py,1,1);
      }
    }
  }
  ctx.restore(); ctx.restore();

  for(const enemy of enemies) enemy.draw();

  const radarLineColor='#333';
  const innerRadii=[radarRadius*0.66,radarRadius*0.33,radarRadius*0.15];
  for(const r of innerRadii){ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.strokeStyle=radarLineColor;ctx.lineWidth=2;ctx.stroke();}
  const angles=[45,135,225,315].map(a=>a*Math.PI/180);
  for(const angle of angles){
    const startX=cx+innerRadii[2]*Math.cos(angle), startY=cy+innerRadii[2]*Math.sin(angle);
    const endX=cx+radarRadius*Math.cos(angle), endY=cy+radarRadius*Math.sin(angle);
    ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(endX,endY);ctx.strokeStyle=radarLineColor;ctx.lineWidth=2;ctx.stroke();
  }
  const time=performance.now()*0.002;
  const lineX=Math.cos(time)*radarRadius, lineY=Math.sin(time)*radarRadius;
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+lineX,cy+lineY);ctx.strokeStyle='#333';ctx.lineWidth=2;ctx.stroke();
  ctx.fillStyle='red';ctx.beginPath();ctx.arc(cx,cy,6,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(cx,cy,radarRadius+4,0,Math.PI*2);ctx.strokeStyle='black';ctx.lineWidth=3;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,radarRadius,0,Math.PI*2);ctx.strokeStyle=radarLineColor;ctx.lineWidth=2;ctx.stroke();
  ctx.restore();
}

function render(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const w=canvas.width,h=canvas.height;
  const bobOffset=Math.sin(player.bobPhase)*1.5;

  // Draw ceiling and floor fixed to top and bottom halves of screen, independent of player.pitch
  ctx.fillStyle='rgb(30,30,40)'; ctx.fillRect(0,0,w,h/2);
  ctx.fillStyle='rgb(150,100,50)'; ctx.fillRect(0,h/2,w,h/2);

  const now=performance.now();
  for(let x=0;x<w;x++){
    const nx=(x-w/2)/(w/2), bulge=nx*nx*nx*0.04;
    const rayAngle=player.angle-FOV/2+((x+bulge*w)/w)*FOV;
    const hit=castRay(player.x,player.y,rayAngle);
    const dist=Math.max(0.001,hit.dist);
    let wallH=(h/Math.max(0.0001,dist*Math.cos(rayAngle-player.angle))); if(wallH>h) wallH=h;
    let r=180+Math.floor((Math.random()-0.5)*2), g=160+Math.floor((Math.random()-0.5)*2), b=80+Math.floor((Math.random()-0.5)*2);
    if(hit.gx!==null){for(const light of flickerLights){if(hit.gx===light.gx&&hit.gy===light.gy){const f=1+Math.sin(now*light.speed+light.phase)*0.3;r=Math.min(255,r*f);g=Math.min(255,g*f);b=Math.min(255,b*f);}}}
    ctx.fillStyle=`rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
    let top = Math.max(h/2 - wallH/2 + bobOffset, 0);
    let bottom = Math.min(h/2 + wallH/2 + bobOffset, h);
    ctx.fillRect(x, top, 1, bottom - top);
  }

  drawRadar();

  const baseRadarRadius=120;
  const radarRadius=baseRadarRadius*1.5;
  const barWidth=w*0.4,barHeight=14;
  const barX=(w - barWidth)/2;
  const barY=h - 0.03*h - barHeight;
  ctx.lineWidth=2;ctx.strokeStyle='#0a0';ctx.fillStyle='#222';ctx.fillRect(barX,barY,barWidth,barHeight);ctx.strokeRect(barX,barY,barWidth,barHeight);
  const fillWidth=(sprintCurrent/sprintMax)*barWidth;
  ctx.fillStyle=isRegenerating?'#a00':'#0a0';ctx.fillRect(barX,barY,fillWidth,barHeight);
}

let last=performance.now();
function loop(){
  const now=performance.now(),dt=(now-last)/1000;last=now;
  const forward=(keys['KeyW']?1:0)-(keys['KeyS']?1:0);
  const strafe=(keys['KeyD']?1:0)-(keys['KeyA']?1:0);
  const dx=(forward*Math.cos(player.angle)-strafe*Math.sin(player.angle))*player.speed;
  const dy=(forward*Math.sin(player.angle)+strafe*Math.cos(player.angle))*player.speed;
  movePlayer(dx,dy,dt);
  for(const enemy of enemies) enemy.update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

canvas.addEventListener('click',()=>canvas.requestPointerLock());
addEventListener('mousemove',e=>{
  if(document.pointerLockElement===canvas){
    player.angle+=e.movementX*0.0022;
  }
});
document.getElementById('fullscreenBtn').addEventListener('click',()=>{if(!document.fullscreenElement)document.documentElement.requestFullscreen();else document.exitFullscreen();});
</script>
</body>
</html>
